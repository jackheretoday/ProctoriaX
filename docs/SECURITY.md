# Security Documentation

## Overview

The Testing Platform implements **defense-in-depth** security with multiple layers of protection to ensure data confidentiality, integrity, and availability.

---

## Security Principles

### 1. **Encryption at Rest**
- All sensitive data encrypted using **AES-256-GCM**
- Questions, answers, and explanations encrypted
- Terms & conditions encrypted
- Excel exports encrypted before storage
- Encryption keys stored securely in environment variables

### 2. **Encryption in Transit**
- HTTPS/TLS for all communications (production)
- Session cookies marked as `Secure` and `HttpOnly`
- CSRF tokens for state-changing requests

### 3. **Authentication**
- Session-based authentication using Flask-Login
- Password hashing with **bcrypt** (cost factor: 12)
- Session timeout: 30 minutes of inactivity
- Logout on browser close

### 4. **Authorization (RBAC)**
- Three roles: **admin**, **teacher**, **student**
- Role-based access control on all endpoints
- Ownership verification for resources
- Principle of least privilege

### 5. **Input Validation**
- Server-side validation on all inputs
- File type validation (.docx, .pptx only)
- File size limits (10MB max)
- SQL injection prevention (ORM parameterized queries)
- XSS prevention (template auto-escaping)

### 6. **Rate Limiting**
- Question upload: 10 requests/hour
- Excel export: 5 requests/hour
- Answer submission: 100 requests/hour
- Login attempts: monitored

---

## Encryption Implementation

### AES-256-GCM Encryption

```python
from cryptography.fernet import Fernet

class EncryptionService:
    @staticmethod
    def encrypt(plaintext: str) -> str:
        """Encrypt using AES-256-GCM"""
        key = os.getenv('ENCRYPTION_KEY').encode()
        f = Fernet(key)
        encrypted = f.encrypt(plaintext.encode())
        return base64.urlsafe_b64encode(encrypted).decode()
    
    @staticmethod
    def decrypt(encrypted: str) -> str:
        """Decrypt encrypted data"""
        key = os.getenv('ENCRYPTION_KEY').encode()
        f = Fernet(key)
        decrypted = f.decrypt(base64.urlsafe_b64decode(encrypted))
        return decrypted.decode()
```

### What Gets Encrypted
- ✅ Question text
- ✅ Answer options (A, B, C, D)
- ✅ Correct answer
- ✅ Explanation
- ✅ Terms & Conditions
- ✅ Excel result files

### What Is NOT Encrypted
- User credentials (hashed, not encrypted)
- Test metadata (name, subject, duration)
- Timestamps
- Non-sensitive configuration

---

## Password Security

### Password Requirements
- Minimum 8 characters
- At least one uppercase letter
- At least one lowercase letter
- At least one digit
- At least one special character

### Password Hashing
```python
from werkzeug.security import generate_password_hash, check_password_hash

# Hashing
password_hash = generate_password_hash(password, method='bcrypt')

# Verification
is_valid = check_password_hash(password_hash, password)
```

### Password Policy
- Passwords never stored in plaintext
- Bcrypt with salt (cost factor: 12)
- No password hints or recovery questions
- Password reset via secure token (future)

---

## Role-Based Access Control (RBAC)

### Role Hierarchy
```
Admin (Superuser)
├── Full system access
├── User management
├── View all tests and results
└── System configuration

Teacher
├── Create/manage own tests
├── Upload questions
├── View own test results
└── Export results

Student
├── View assigned tests
├── Take tests
├── View own results
└── Review answers
```

### Implementation
```python
from functools import wraps
from flask_login import current_user

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('auth.login'))
        if current_user.role != 'admin':
            abort(403)
        return f(*args, **kwargs)
    return decorated_function
```

---

## CSRF Protection

### Implementation
- CSRF tokens on all POST/PUT/DELETE requests
- Token validation server-side
- Auto-generated by Flask-WTF

### Usage
```html
<form method="POST">
    {{ csrf_token() }}
    <!-- form fields -->
</form>
```

---

## Rate Limiting

### Configuration
```python
from flask_limiter import Limiter

limiter = Limiter(
    key_func=lambda: current_user.id if current_user.is_authenticated else request.remote_addr,
    default_limits=["200 per day", "50 per hour"]
)

# Endpoint-specific limits
@limiter.limit("10 per hour")
def upload_questions():
    pass
```

### Protected Endpoints
- Question upload: 10/hour
- Excel export: 5/hour
- Answer submission: 100/hour
- API calls: 50/hour (default)

---

## Session Security

### Session Configuration
```python
app.config.update(
    SESSION_COOKIE_SECURE=True,      # HTTPS only
    SESSION_COOKIE_HTTPONLY=True,    # No JavaScript access
    SESSION_COOKIE_SAMESITE='Lax',   # CSRF protection
    PERMANENT_SESSION_LIFETIME=1800  # 30 minutes
)
```

### Session Management
- Server-side session storage
- Session ID rotation on login
- Automatic expiration
- Logout clears session completely

---

## File Upload Security

### Validation
```python
ALLOWED_EXTENSIONS = {'.docx', '.pptx'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

def validate_file(file):
    # Check extension
    if not allowed_file(file.filename):
        raise ValidationError("Invalid file type")
    
    # Check size
    file.seek(0, os.SEEK_END)
    size = file.tell()
    if size > MAX_FILE_SIZE:
        raise ValidationError("File too large")
    
    file.seek(0)
    return True
```

### Upload Process
1. Validate file type and size
2. Generate secure filename
3. Save to temporary directory
4. Parse and validate content
5. Delete temporary file
6. Store processed data (encrypted)

---

## Audit Logging

### What Gets Logged
- User login/logout
- Test creation/deletion
- Question uploads
- Test submissions
- Results viewing
- Excel exports
- Failed authentication attempts
- Suspicious activities

### Log Format
```python
{
    "timestamp": "2024-01-01T10:00:00",
    "user_id": 15,
    "action": "test_created",
    "resource": "test_id:5",
    "ip_address": "192.168.1.100",
    "user_agent": "Mozilla/5.0...",
    "status": "success"
}
```

---

## SQL Injection Prevention

### Using ORM
```python
# SAFE - Parameterized query via ORM
user = User.query.filter_by(username=username).first()

# UNSAFE - Never do this
query = f"SELECT * FROM users WHERE username='{username}'"
```

### Best Practices
- Always use SQLAlchemy ORM
- Never concatenate SQL strings
- Validate all inputs
- Use prepared statements

---

## XSS Prevention

### Template Auto-Escaping
```html
<!-- Automatically escaped -->
<p>{{ user_input }}</p>

<!-- Manual escaping if needed -->
<p>{{ user_input | e }}</p>

<!-- Unsafe (only for trusted content) -->
<p>{{ trusted_html | safe }}</p>
```

### Content Security Policy (Future)
```python
@app.after_request
def set_csp(response):
    response.headers['Content-Security-Policy'] = "default-src 'self'"
    return response
```

---

## Timer Security (Student Module)

### Client-Side Timer
- JavaScript countdown for UX
- LocalStorage for persistence
- Visual warnings

### Server-Side Validation
- Start time stored in session
- End time calculated server-side
- Validation on every request
- Auto-submit if expired

```python
# Verify time remaining
end_time = session.get(f'test_{test_id}_end_time')
if datetime.now() >= datetime.fromisoformat(end_time):
    # Auto-submit test
    return submit_test(test_id)
```

---

## Navigation Control Security

### Prevent Cheating
- Browser back button disabled
- Page refresh warns user
- Tab switching detected (logged)
- Dev tools discouraged
- Right-click disabled during test

### Implementation
```javascript
// Disable back button
history.pushState(null, null, location.href);
window.onpopstate = function() {
    history.go(1);
};

// Warn on page leave
window.onbeforeunload = function() {
    return "Test in progress!";
};
```

---

## Sensitive Data Handling

### Data Classification
- **Critical**: Passwords, encryption keys, API keys
- **Sensitive**: Questions, answers, student results
- **Public**: Test names, subjects, descriptions

### Storage Guidelines
- Critical: Environment variables, never in code
- Sensitive: Encrypted in database
- Public: Normal database storage

### Environment Variables
```bash
SECRET_KEY=<strong-random-key-64-chars>
ENCRYPTION_KEY=<strong-random-key-32-bytes>
DATABASE_URL=<connection-string>
```

---

## Security Headers

### Recommended Headers (Production)
```python
@app.after_request
def security_headers(response):
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000'
    return response
```

---

## Vulnerability Scanning

### Dependencies
```bash
# Check for vulnerable dependencies
pip install safety
safety check

# Update vulnerable packages
pip install --upgrade <package>
```

### Code Analysis
```bash
# Static analysis
pip install bandit
bandit -r app/

# Find secrets in code
pip install detect-secrets
detect-secrets scan
```

---

## Incident Response

### Security Incident Protocol
1. **Detect**: Monitor logs for suspicious activity
2. **Contain**: Disable affected accounts
3. **Investigate**: Analyze logs and audit trail
4. **Remediate**: Fix vulnerability
5. **Document**: Record incident details
6. **Review**: Update security measures

### Contact
- Security Issues: security@example.com
- Emergency: Use incident response hotline

---

## Security Checklist

### Development
- [ ] No hardcoded credentials
- [ ] All inputs validated
- [ ] Errors don't leak sensitive info
- [ ] CSRF protection enabled
- [ ] Secure session configuration

### Deployment
- [ ] HTTPS enabled
- [ ] Strong encryption keys
- [ ] Database credentials secured
- [ ] File permissions correct
- [ ] Security headers configured
- [ ] Rate limiting active
- [ ] Logging enabled

### Maintenance
- [ ] Regular dependency updates
- [ ] Security patches applied
- [ ] Audit logs reviewed
- [ ] Backup encryption verified
- [ ] Access controls reviewed

---

## Compliance

### Data Protection
- Minimal data collection
- Clear data retention policy
- User data export capability (future)
- Right to deletion (future)

### Academic Integrity
- Encrypted question storage
- One-time test access
- No back navigation
- Timer enforcement
- Result integrity

---

## Future Enhancements

1. **Two-Factor Authentication** (2FA)
2. **API Key Management**
3. **IP Whitelisting**
4. **Advanced Threat Detection**
5. **Security Information and Event Management (SIEM)**
6. **Penetration Testing**
7. **Bug Bounty Program**

---

**Security Version**: 1.0  
**Last Review**: 2024  
**Next Review**: Quarterly
